/**
 * Encrypt and decrypt data using keys generated by device ID.
 */
import * as crypto from 'crypto';
import { machineIdSync } from 'node-machine-id';
import { generateKeyFromDeviceId } from './key-generator';
import * as fs from 'fs';

// Encrypt algorithm and IV length
const ALGORITHM = 'aes-256-cbc';
const IV_LENGTH = 16;

const DEVICE_ID = machineIdSync();
const ENCRYPTION_KEY = generateKeyFromDeviceId(DEVICE_ID);

/**
 * Encrypt Json object
 * @param data Data to be encrypted
 * @param key Encryption key, default is generated by device ID
 * @param iv Encryption IV, default is random generated bytes
 * @returns Encrypted string separated with ':' - {iv}:{encrypted data}
 */
export function encryptJson(
  data: object,
  key: crypto.CipherKey = ENCRYPTION_KEY,
  iv: crypto.BinaryLike = crypto.randomBytes(IV_LENGTH)
): string {
  const CIPHER = crypto.createCipheriv(ALGORITHM, key, iv);
  const jsonData = JSON.stringify(data);

  const encrypted = Buffer.concat([
    CIPHER.update(jsonData, 'utf-8'),
    CIPHER.final(),
  ]);

  return (
    Buffer.from(iv as Uint8Array).toString('hex') +
    ':' +
    encrypted.toString('hex')
  );
}

/**
 * Decrypt data into Json object
 * @param encryptedData Encrypted Json data separated with ':' - {iv}:{encrypted data}
 * @param key Decryption key, default is generated by device ID
 * @returns Decrypted Json object
 */
export function decryptJson(
  encryptedData: string,
  key: Buffer = ENCRYPTION_KEY
): object | null {
  try {
    const [ivHex, encryptedHex] = encryptedData.split(':');
    const iv = Buffer.from(ivHex, 'hex');
    const encryptedText = Buffer.from(encryptedHex, 'hex');

    const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);

    const decrypted = Buffer.concat([
      decipher.update(encryptedText),
      decipher.final(),
    ]);

    return JSON.parse(decrypted.toString('utf-8'));
  } catch (e) {
    console.error('Decryption failed: ', e);
    return null;
  }
}

/**
 * Encrypt file
 * @param filePath File to be encrypted
 * @param encryptPath Encrypted file output path
 * @param key Encryption key, default is generated by device ID
 * @param iv Encryption IV, default is random generated bytes
 * @returns The IV of the file
 */
export function encryptFile(
  filePath: string,
  encryptPath: string,
  key: Buffer = ENCRYPTION_KEY,
  iv: crypto.BinaryLike = crypto.randomBytes(IV_LENGTH)
): crypto.BinaryLike | void {
  try {
    const cipher = crypto.createCipheriv(ALGORITHM, key, iv);

    const input = fs.createReadStream(filePath);
    const output = fs.createWriteStream(encryptPath);

    output.write(iv); // Prepend IV to the encrypted file

    input
      .pipe(cipher)
      .pipe(output)
      .on('finish', () => {
        console.log(`File encrypted successfully to: ${encryptPath}`);
      });

    return iv;
  } catch (e) {
    console.error('File encryption failed: ', e);
  }
}

/**
 * Decrypt encrypted file
 * @param encryptedPath Encrypted file path
 * @param decryptPath Decrypted file output path
 * @param iv Decrypt algorithm IV
 */
export function decryptFile(
  encryptedPath: string,
  decryptPath: string,
  key: crypto.CipherKey = ENCRYPTION_KEY,
  iv: string
): void {
  try {
    const encryptedData = fs.readFileSync(encryptedPath);
    const ivBuffer = Buffer.from(iv, 'hex');

    const decipher = crypto.createDecipheriv(ALGORITHM, key, ivBuffer);

    const decrypted = Buffer.concat([
      decipher.update(encryptedData),
      decipher.final(),
    ]);

    fs.writeFileSync(decryptPath, decrypted);
    console.log(`File decrypted successfully to: ${decryptPath}`);
  } catch (e) {
    console.error('File decryption failed: ', e);
  }
}
